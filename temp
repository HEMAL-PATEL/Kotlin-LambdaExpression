        1. thread synchriinisation, enumaration, enum, oops concept
        2. Design Patttern : mvc,mvvp,
        3. multiple file downlod , how to accoumplish
        4. service :started, bounded, diff, where we use started and where we  use bounded
        5. fragment life cycle
        6. how to pass data from fragments viewpager to activiity
        7. cursor adapter, what is, how to use
        8. recyclerview click listener
        9. hashmap, diff between map and set
        10. can we pass haspmap to custom adapter
        11. fragment life cycle
        12. activity life cycle
        13. ---ENGLISH---
		
		
1. Activity life cycle
2. Fragment life cycle
3. Serializable, Parcelable
4. Android Component
5. Android Architecture
6. Broadcast Receiver
7. Even-Odd number using 
8. Fragment methods called when Add/replace new fragment
9. GCM ,FCM
10. Firebase
11. 11.1 Activity methods called when switch activity to background/kill/backgroundToForground
    11.2 Activity methods called when move from one activity to another activity
	11.3 same for fragment
	11.4 if application service called from app will kill or not
12. HashMap, Hashset
13. Inharitance
	13.1 IS-A relationship Ex. with program
	13.1 HAS-A relationship Ex. with program
14. Polymorphism and its types: Ex. and Code (Overloading & overriding NOT Confirm pls check)
	1. Runtime Ex. with program
	2. CompileTime Ex. with program
15. abstrct class and interface
16. Thread and details, LifeCycle
17. Class 
18. Mutable objects/class, Immutable objects/class
	18.1 Mutable class : you can extend these class Ex.Normal class .. to make these class ImMutable place final keyword in class declaration
	18.2 ImMutable class : you can not extend these class, Ex. String class
19. Push Notification, Firebase
20. sqllite DB, Datatypes
21. Collection , Sort method, collection sort
22. Diff Service & Thread 	
23. Handlers
24. Worker thread, main UI thread
25. Webservices means, types, JSON (Full form)
	1. RESTful
	2. SOAP
	3. Diff between above both
26. Program for prime numbers count
27. Study abount coherant
28. Marker interface :
    1. Ex. Serialisable, findMore example
    2. it(interface) doesn't have any implementaion 
    3. but compiler knows that what to do with class which implements marker inteface
29. diff == and .equals
30. Collection interfaces****
31. Service exported=true meaning
32. Pending Intent?
	Ans - A Pending Intent is a token you give to some app to perform an action on your apps' behalf irrespective of whether your application process is alive or not.
	Just think of use-cases for PIs like (Broadcasting Intents, scheduling alarms) and the documentation will become clearer and meaningful.
33. FrameLayout Vs RelativeLayout
34. Activity LaunchModes

35. Greate article  : https://medium.com/exploring-android/exploring-background-execution-limits-on-android-oreo-ab384762a66c
	
	Diff. LinkedList & ArrayList  : when to use ArrayList and when to use linkedList
    Hashmap equals and HashCode method
    Can we store object in hashmap
    Diff between equals and ==
	primitive datatype and Non-primitive datatype

	** How you choose library that which one to use
    Lifecycle methods Activity/ frgament

	
//-------------------------------------------------------------------------------------------------		

*** Great source ***
http://skillgun.com/question/3900/android-mportal/technical/what-is-mutable-and-imutable-explain-with-examples-java

//-------------------------------------------------------------------------------------------------	
		
Android must have libraries :
1. Butterknife :
2. Gson :
3. Volley :
4. Picasso

Android Studion must have plugins :
1. ADB idea
2. CodeGlance

//-------------------------------------------------------------------------------------------------	
Programs :
1. Even-Odd :
	1.1 using bitwise operator
	 - number & 1 will give you the last digit of the binary number.
	For example , 5 is odd, let us find out using bitwise AND(&amp;) operation
	0000 0101 & 0000 0001 = 0000 0001, as the last digit of the binary number is 1 , then it is odd.
	Ex.  if( (number&1) == 0){"Even"} else {"Odd"}
	1.2 using modulus operator 
	 - Ex.  if( (number%2) == 0){"Even"} else {"Odd"}

//-------------------------------------------------------------------------------------------------	
Brodcast receiver :

1. Define uniuqe key :
public static String CHECK_DATA = "com.example.data";

2. Register brodcast in OnCreate Method
registerReceiver(mGetDataBroadcastReceiver, new IntentFilter(CHECK_DATA));

3. Unregister brodcast in OnDestroy method :
	@Override
    protected void onDestroy()
    {
        super.onDestroy();
        unregisterReceiver(mGetDataBroadcastReceiver);
    }
	
4. Define Brodcast :

  BroadcastReceiver mGetDataBroadcastReceiver = new BroadcastReceiver()
    {
        @Override
        public void onReceive(Context context, Intent intent)
        {
            // Do write your stuff here
        }
    };
	
5. Send Brodcast :
		Intent intent = new Intent();
		intent.setAction(CHECK_DATA);
        sendBroadcast(intent);

//-------------------------------------------------------------------------------------------------	
Intent Service Example :

1. GetData.java
	public class GetData extends IntentService
	{
		public GetData()
		{
			super("GetData");
		}
	
		@Override
		protected void onHandleIntent(Intent intent)
		{
			// call api/DB operation or any other stuff.
		}	
	}

2. Manifest :
	<service
    android:name="com.example.services.GetData"
    android:enabled="true"
    />
	
3. Call to service :
	   Intent intent = new Intent(this, GetData.class);
       startService(intent);
	   
//-------------------------------------------------------------------------------------------------	
public class app extends Application
{
	private static Context gContext;
	private static app mInstance;
	public void onCreate()
	{
        super.onCreate();
        gContext = getApplicationContext();
        mInstance = this;
	}
	
	public static synchronized app getInstance()
    {
        return mInstance;
    }
}

//-------------------------------------------------------------------------------------------------	

Android CustomView

1. IconView.java
public class IconView extends TextView
{
    private static final Map<String, Typeface> TYPEFACES = new HashMap<>();
    private static final String TAG = "IconView";

    public IconView(Context context)
    {
        super(context);
    }

    public IconView(Context context, AttributeSet attrs)
    {
        super(context, attrs);
        setFont(context, attrs);
    }

    public IconView(Context context, AttributeSet attrs, int defStyle)
    {
        super(context, attrs, defStyle);
        setFont(context, attrs);
    }

    private void setFont(Context context, AttributeSet attrs)
    {
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.IconView);
        String customFont = a.getString(R.styleable.IconView_font);

        if (customFont == null) customFont = "icomoon.ttf";
        setFont(customFont);

        a.recycle();
    }

    public boolean setFont(String asset)
    {
        Typeface typeface = null;
        try
        {
            typeface = get(asset);
        } catch (Exception e)
        {
            Log.e(TAG, "Could not set TypeFace : " + e.getMessage());
            return false;
        }
        setTypeface(typeface);
        return true;
    }

    public Typeface get(String fontFileName)
    {
        Typeface typeface = TYPEFACES.get(fontFileName);
        if (typeface == null)
        {
            typeface = Typeface.createFromAsset(getContext().getResources().getAssets(), fontFileName);
            TYPEFACES.put(fontFileName, typeface);
        }
        return typeface;
    }
}


2. res/values/attrs.xml
	<?xml version="1.0" encoding="utf-8"?>
	<resources>
		<declare-styleable name="IconView">
			<attr name="font"
				format="string" />
			<attr name="appendText"
				format="string" />
		</declare-styleable>
	</resources>

//-------------------------------------------------------------------------------------------------

Network Call : UrlConnection

1. JsonRequest.java

public class JsonRequest
{
    private String mURL;
    private Context mContext;
    private GetResponce mListener;

    public JsonRequest(Context context, String url, GetResponce listener)
    {
        mURL = url;
        mContext = context;
        mListener = listener;
        new LoadData(mContext).execute();
    }

    public class LoadData extends AsyncTask<String, String, String>
    {
        private Context mContext;
        private ProgressDialog dialog;

        public LoadData(Context context)
        {
            mContext = context;
            dialog = new ProgressDialog(mContext);
            dialog.setMessage("Please wait...");
        }

        @Override
        protected void onPreExecute()
        {
            dialog.show();
            super.onPreExecute();
        }

        @Override
        protected String doInBackground(String... strings)
        {
            URLConnection urlConnection;
            BufferedReader reader = null;
            String forecastJsonStr = null;

            try
            {
                URL url = new URL(mURL);
                urlConnection = (HttpsURLConnection) url.openConnection();
                urlConnection.connect();

                InputStream inputStream = urlConnection.getInputStream();
                StringBuffer buffer = new StringBuffer();
                if (inputStream == null)
                {
                    return null;
                }
                reader = new BufferedReader(new InputStreamReader(inputStream));

                String line;
                while ((line = reader.readLine()) != null)
                {
                    buffer.append(line + "\n");
                }

                if (buffer.length() == 0)
                {
                    return null;
                }
                forecastJsonStr = buffer.toString();

            } catch (Exception e)
            {
                e.printStackTrace();
            }
            return forecastJsonStr;
        }

        @Override
        protected void onPostExecute(String s)
        {
            dialog.dismiss();
            if (s != null)
            {
                mListener.onGetResponce(s);
            } else
            {
                Toast.makeText(mContext, "Network connection error", Toast.LENGTH_SHORT).show();
            }

            super.onPostExecute(s);
        }
    }

    public interface GetResponce
    {
        public void onGetResponce(String responce);
    }
}


2. MainActivity.java

public class MainActivity extends AppCompatActivity
{
    private String mURL = "https://yts.ag/api/v2/list_movies.json";

    @Override
    protected void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //call api
        new JsonRequest(this, mURL, new GetResponce()
        {
            @Override
            public void onGetResponce(String responce)
            {
                Log.e("--PRINT RESPONCE--",""+responce);
            }
        });
    }
}

3. Add Internet permission in manifest

	  <uses-permission android:name="android.permission.INTERNET" />
//-------------------------------------------------------------------------------------------------
Singleton Database object :

1. DatabaseHelper.java

	private static DatabaseHelper mInstance = null;
		
	public static synchronized DatabaseHelper getInstance(Context context)
    {
        if (mInstance == null)
        {
            mInstance = new DatabaseHelper(context);
        }
        return mInstance;
    }
	
2. MainActivity.java
	
	private SQLiteDatabase mDb;
    private DatabaseHelper dbHelper;
    
	dbHelper = DatabaseHelper.getInstance(this);
    mDb = dbHelper.getWriteable(this);
//-------------------------------------------------------------------------------------------------	
DatabaseHelper onUpgrade method : 
	
	@Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)
    {
        for (int i = oldVersion; i < newVersion; i++)
        {
            switch (i)
            {
                case 1:
                    db.execSQL(Constants.CREATE_TABLE_ACCOUNTS);
                    break;
                case 2:
                    break;
                default:
                    break;
            }
        }
    }
//-------------------------------------------------------------------------------------------------
Inline AsyncTask :
1. The Basic
new AsyncTask<Void, Void, Void>() {
        protected void onPreExecute() {
                // Pre Code
        }
        protected Void doInBackground(Void... unused) {
                // Background Code
                return null;
        }
        protected void onPostExecute(Void unused) {
                // Post Code
        }
}.execute();


2. Return msg from doInBackground to onPostExecute
new AsyncTask<Void, Void, String>() {
        protected String doInBackground(Void... params) {
                return "message";
        }
        protected void onPostExecute(String msg) {
              
              Log.e("TAG",msg) 
        }
}.execute();
//-------------------------------------------------------------------------------------------------        
		
Theory :
1. Android component 

	1.1 Activities 
		- They dictate the UI and handle the user interaction to the smart phone screen.
	1.2 Services
		- They handle background processing associated with an application.	
		- A service is a component that runs in the background to perform long-running operations. 
	1.3 Broadcast Receivers
		- They handle communication between Android OS and applications.
		- Broadcast Receivers simply respond to broadcast messages from other applications or from the system.
		- A broadcast receiver is implemented as a subclass of BroadcastReceiver class and each message is broadcaster as an Intent object.
	1.4 Content Providers
		- They handle data and database management issues.
		- A content provider component supplies data from one application to others on request. Such requests are handled by the methods of the ContentResolver class. The data may be stored in the file system, the database or somewhere else entirely.

		
2. what is the Concrete class in java?
	- A concrete class is a class that has an implementation for all of its methods that were inherited from abstract or implemented 
	via interfaces. It also does not define any abstract methods of its own. This means that an instance of the class can be 
	created/allocated with the new keyword without having to implement any methods first. Therefore it can be inferred that any class 
	that is not an abstract class or interface is a concrete class.
	Ex-1. ArrayList is ocncreate class
	Ex-2. 
	public abstract class A {
		public abstract void methodA();
		}

	interface B {
		public void printB();
		}

	public class C extends A implements B {
		public void methodA() {
        System.out.print("I am abstract implementation");
		}

	public void printB() {
       System.out.print("I am interface implementation");
		}
	- In your code above, C will be a concrete class as it implements all abstract methods inherited from A and implemented from B. Also, it does not define any abstract methods of its own.
}

3.1. Intent Service
IntentService runs on its own thread. It will stop itself when its done. More like fire and forget. Subsequent calls will be queued. Good for queuing calls. 
You can also spin multiple threads within IntentServiceif you need to- You can achieve this using ThreadPoolExecutor. 
I say this because many people asked me "why use IntentService since it doesn't support parallel execution". IntentService is just a thread.
You can do whatever you need inside it- Even spinning multiple threads. Only caveat is that IntentService is finish as soon as you spin those multiple threads. 
It doesn't wait for those threads to come back. You need to take care of this . So I recommend using ThreadPoolExecutor in those scenarios.
E.g. Good for Syncing, uploading etc …

2. Service
By Default Service runs on the main thread. You need to spin a worker thread to do your job. You need stop service explicitly. 
I used it for situation when you need to run stuff in the background even when you move away from your app and come back more for a Headless service.
    - Again you can run multiple threads if you need to.
    - Can be used for apps like music players.
You can always communicate back to your activity using BroadcastReceivers if you need to.  

Q.1 - Intent service executes in sequetialy, Use threadpool to do parallel task.

4. Activity life cycle methods:
	1. onCreate()
	2. onStart()
	3. onResume()
	4. onPause()
	5. onStop()
	6. onDestroy()

5. Fragment life cycle methods:	

6. Android Oreo changes : 
	IMP ** : https://medium.com/@kevalpatel2106/how-to-handle-background-services-in-android-o-f96783e65268
	1. Background execution limits
    2. Location updates limit
    3. Removing of implicit broadcasts
    4. Notification channels
	
	6.1 Why do we need to restrict the use of background services?
		1. Memory
		2. Battery
		
7. Jobscheduler :
		1. 	JobScheduler api introduced in API21 to perform background tasks.
		2. 	This API allows you to run scheduled service and the android system will batch all the services 
		    from different applications and run them together in some particular timeframe. 
			The reason behind this is to reduce the amount of time your phone’s CPU and radio wakes up by batching the tasks together. This will consume less battery and maintains system health.
	
8. Fragment add/replace code :
		FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
        fragmentTransaction.replace(R.id.container, fragment);
        fragmentTransaction.commit();
		
10.  lateinit var mTxt: TextView
	 mTxt = findViewById(R.id.textView) as TextView
	 
	 private var presenter: DashBoardPresenterImpl? = null	
	 presenter = DashBoardPresenterImpl(this);
	 
	 mTxt.text = "Recyclerview using kotlin"
	  
	 10.1 There is no new keyword in kotlin
	 10.2 NO semicolon
	 10.3 Powerful lambda expressions
	 
11. Activity Launched modes
		1. Standard
		2. SingleTop
			In this launch mode if an instance of activity already exists at the top of the current task, 
			a new instance will not be created and Android system will route the intent information through onNewIntent(). 
			If an instance is not present on top of task then new instance will be created.
		3. SingleInstance
			This is very special launch mode and only used in the applications that has only one activity. 
			It is similar to singleTask except that no other activities will be created in the same task. 
			Any other activity started from here will create in a new task.
			T1 = A-B-C on launch of D(SingleInstance) T2 = D. again launch E then will get added into T1 = A-B-C-E 
			now launch again D then T2 = D (intent data route through onNewIntent())
		4. SingleTask
			in this mode, old activity instance is called and intent data is route through onNewintent()
			A-B-C-D now if we launch B (singleTask) , stack will be A-B.Intent data will be through onNewIntent()
